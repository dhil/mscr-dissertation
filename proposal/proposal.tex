%\documentclass[a4paper,11pt,twoside]{article}
\documentclass[preprint,10pt,numbers]{sigplanconf}
\usepackage[utf8]{inputenc}          % UTF-8 Encoding
\usepackage{hyperref}                % Interactive PDF
\usepackage{float}                   % Float control
\usepackage{multirow}                % Span multiple rows & columns in a table
\usepackage{amsmath}                 % Mathematics library
\usepackage{amssymb}                 % Provides math fonts
\usepackage{amsthm}                  % Provides \newtheorem, \theoremstyle, etc.
\usepackage[T1]{fontenc}             % Fixes font issues
\usepackage{lmodern}
%\usepackage[
%backend=bibtex,
%style=numeric,
%sorting=nyt
%]{biblatex}                   % Bibliography
%\addbibresource{references.bib}


% Convenient macros
\newcommand{\defas}[0]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}} % "defined-as-equal"

%% Meta-stuff like authors, title, etc.
%\author{Daniel Hillerström\\\small{CDT in Pervasive Parallelism}\\\small{\href{mailto:daniel.hillerstrom@ed.ac.uk}{daniel.hillerstrom@ed.ac.uk}}}
%\date{\today}
%\title{Proposal: Effective Concurrency in Links} % Just some title; change at a later point.

% The document
\begin{document}
\title{Effective Concurrency in Links}
%\subtitle{via handlers}

\authorinfo{Daniel Hillerström}
           {CDT Pervasive Parallelism}
           {\href{mailto:daniel.hillerstrom@ed.ac.uk}{daniel.hillerstrom@ed.ac.uk}}
  \maketitle
  \begin{abstract}
    An abstract will appear here\dots
  \end{abstract}
  \raggedbottom
  % Input the content
  \section{Introduction}
Run-time scheduling is a domain-specific problem as the performance goal of a scheduler can be paramount to the overall performance of a program. Consequently, schedulers employ different metrics to measure performance. For example, \emph{high-throughput} schedulers seek to optimise the throughput of jobs \cite{Berman2003}, hence performance might be measured by the number of jobs processed by the system. Criteria such as fairness or utilisation might be used to measure the performance of \emph{resource} schedulers as they seek to coordinate accesses to shared resources \cite{Berman2003}. Furthermore, \emph{high-performance} schedulers seek to minimise execution time for a single program. In this case performance is measured by the raw execution speed.

Thus scheduling is important. However, scheduling is often the responsibility of the compiler writer, but the concern of the application programmer. For example, grid-based computations may benefit from neighbouring points being scheduled together. Yet the programmer has little or no say about the matter as schedulers typically are baked into the run-time system \cite{Dolan2015}. 

We propose to rectify this mismatch by transferring the responsibility for scheduling to the application programmer. Concretely, we propose to abstract over the choice of scheduling by adapting the approach taken by Multicore OCaml \cite{Dolan2015} to use Plotkin and Pretnar's \emph{handlers for algebraic effects} \cite{Plotkin2013} to encode concurrency primitives. Specifically, we plan implement a backend for the functional programming language Links \cite{Cooper2006}, and take advantage of its existing implementation of algebraic effect handlers \cite{Hillerstrom2015} to encode Links' concurrency primitives.

  % Plotkin and Power's algebraic effects \cite{Plotkin2001} combined with Plotkin and Pretnar's handlers \cite{Plotkin2013} yield a programming model for controlling computational effects. An algebraic effect is a collection of abstract operations without predefined semantics. Handlers interpret algebraic effects by assigning semantics to abstract operations. Thus, the control of computational effects is lifted from the run-time system into the hands of the programmer. Clearly, it shifts additional responsibility onto the programmer, however, in addition it opens up a design space that was previously secluded from the programmer. Now, the programmer may extend the capabilities of the run-time system beyond what the language implementor envisaged.

  % For example, it is well-known that concurrency primitives can be encoded through algebraic effects \cite{Bauer2015,Dolan2015} as spawning a new thread is an effect. Furthermore, suspending a thread is an effect. Handlers of these effects are schedulers. Hence, the programmer is free to implement a particular scheduling policy tailored for the application. The choice of scheduler can have significant impact on performance as a scheduler's performance goal can be paramount to the overall performance of an application \cite{Berman2003}.

  % However\dots

  \section{Problem definition}
%  Although, handlers for algebraic effects have many practical applications \cite{Kammar2013,Bauer2015,Hillerstrom2015,Dolan2015}, there does not yet exist an efficient implementation of handlers. Multicore OCaml implements linear handlers which only allow the continuation invoked once. This restriction is enforced during run-time. Furthermore, because OCaml lacks an effect system\dots
Run-time scheduling is recognised as an important problem for performance \cite{Augonnet2011,Augonnet2012,Agullo2015}. In particular in the field of high-performance computing where scheduling is concerned about exploiting heterogeneity to accelerate computations. There already exists many tools that attempt to solve this problem, e.g. CellSs \cite{Bellens2009}, StarSS \cite{Planas2009}, StarPU \cite{Augonnet2011}, QUARK \cite{YarKhan2011}, PaRSEC \cite{Bosilca2013} to mention a few.

These tools take a common approach to scheduling: Given a task-graph-based description of a program, they will attempt to map individual tasks onto computational devices. Most of the tools seek to do this mapping automatically.

However, the key observation is, that, the aforementioned tools provide weak abstractions that makes scheduling non-modular. Support for schedulers is added by resorting to compile-time meta programming in a foreign language such as \texttt{pragmas}. Hence, schedulers become tightly coupled with computations. Consequently, it is nontrivial to reuse a particular scheduler or change scheduler.
% Moreover, the programmer still has a limited say.

Ideally, we would want schedulers to be first-class citizens in the host language. Therefore, we ask the following question:
\begin{center}
  \emph{How may we reify schedulers as an integrated host language construct?}
\end{center}

  \section{Proposed solution}

  \section{Background}
  \subsection{Links programming language}
  Links is a strongly, statically typed functional programming language oriented towards web-programming \cite{Cooper2006}. Notably, Links implements effect handlers as first-class citizens \cite{Hillerstrom2015}. Moreover, the implementation support both deep and shallow handlers. However, since Links is an interpreted language the performance of handlers is low.

  \subsection{Optimisation of single-shot continuations}

  \subsection{Handlers implementations}
  This section briefly surveys existing implementations of effect handlers. Section \ref{sec:first-class} considers languages with first-class handlers, whilst Section \ref{sec:library} discusses embeddings of handlers in the pure functional programming language Haskell.
  \subsubsection{First-class implementations}\label{sec:first-class}
  \begin{table}[H]
    \centering 
    \begin{tabular}{| l | l | l |}
      \hline
      \multicolumn{1}{|c|}{Language} & \multicolumn{1}{c|}{Handlers} & \multicolumn{1}{c|}{Developed by} \\
      \hline
      Eff & Deep handlers & Bauer and Pretnar \\ 
      \hline
      Frank & Shallow handlers & McLaughlin, Lindley and McBride \\    
      \hline
      Links & Shallow and deep handlers & Hillerström and Lindley\\
      \hline
      Multicore OCaml & Deep handlers & OCamlLabs \\
      \hline    
    \end{tabular}\caption{Languages with first-class effect handlers.}\label{tbl:impls}
  \end{table}
  Table \ref{tbl:impls} provide an overview of languages where effect handlers are first-class citizens. 

The Eff language is a OCaml-style language with deep handlers. It support for effect polymorphism through subtyping \cite{Bauer2015}. 
The functional programming Links implements both deep and shallow handlers \cite{Hillerstrom2015}. Moreover, the implementation supports effect polymorphism through Links' existing row polymorphic effect system.
    
  \subsubsection{Library implementations}\label{sec:library}

  \section{Evaluation}
  The primary metric for evaluation of the proposed solution will be performance. As discussed earlier there are various metrics for measuring performance. We intend to mainly measure performance by raw execution speed. Furthermore, we intend to compare our performance results against results for similar programs written in C since it is considered a ``performant'' language. 

Additionally, we will consider the safety of our solution, i.e. which static guarantees, if any, can we exhibit. In order to evaluate safety we intend to give a formal proof of the said properties.

Furthermore, we would like to qualitatively assess the ease of use, that is, whether the handler abstraction makes concurrent programming easier.

  \section{Project feasibility}
  \subsection{Risk analysis}

  \subsection{Project plan}
  \begin{table}[H]
    \centering
    \begin{tabular}{ | l | c | c | c | c | c | }
      \hline
      \multicolumn{1}{|c|}{Activity / Weeks} & 2-4 & 5-9 & 10-17 & 18-21 & 22-33 \\
      \hline
      Prototyping    & X & X & & & \\
      \hline
      Implementation & X & X & X & X & X \\
      \hline
      Testing        & X & X & X & X & X \\
      \hline
      Evaluation     &   &   & X & X & X \\
      \hline
      Related work   &   & X & X &   & X \\
      \hline
      Exam period    &   &   &   & X &   \\
      \hline
      Write up       & X & X & X & X & X  \\
      \hline
    \end{tabular}\caption{Activity overview.}
  \end{table}
  % Bibliography
\bibliographystyle{abbrvnat}
\softraggedright
\nocite{*}
\bibliography{references}
%  \printbibliography[heading=bibintoc]
\end{document}