# An attempt at encoding the concurrency model of Links using effect
# handlers.
#
# Ideally, the implementation should meet the following criteria:
#
# 1. Messages can only be sent to existing processes
# 2. Process types carry effect information, e.g. Process({Foo:(Bar) {}-> Baz |e})
# 3. Mailboxes are heterogeneous
#

# typename Option(a) = [|None
#                       |Some:a
#                       |];

# typename Priority  = [|Low
#                       |Medium
#                       |High
#                       |];

# Generic execution unit type (process or thread)
typename ExecutionUnit(id::Type,inp::Type,e::Row,out::Type) =
         (id:id, comp:(inp) -e-> out);

typename Pid = String;
var pidToString = id;

typename PackedProcess(e::Row,y::Type) = forall p :: Row . (ExecutionUnit(Pid,(),{ |e},())) -p-> y;
typename EProcess(e::Row) = forall y, p :: Row . (PackedProcess({ |e}, y)) -p-> y;

sig makeExecutionUnit : ((a) -e-> b, id) -> ExecutionUnit(id, a, { |e}, b)
fun makeExecutionUnit(f, id) {
    (id=id, comp=f)
}

sig makeProcess : (() -e-> (), Pid) -> EProcess({ |e})
fun makeProcess(f, pid) {
    var eu = makeExecutionUnit(fun(_) { f() }, pid);
    fun( p : PackedProcess({ |e}, y) ) {
       p(eu)
    }
}

sig getPid : (EProcess({ |e})) -> Pid
fun getPid(proc) {
    #var packedFun = (fun(proc) { proc.id } : PackedProcess({ |e}, Pid) );
    var packedFun = fun(proc) { proc.id };
    proc(packedFun)
}

sig myPid : () {MyPid:Pid|_}-> Pid
fun myPid() {do MyPid}

sig makeChildPid : (EProcess({ |e}), Int) -> Pid
fun makeChildPid(parent, childNumber) {
    getPid(parent) ^^ "." ^^ intToString(childNumber)
}


# Process creation
sig pspawn : (() -e-> ()) {Spawn:(() -e-> ()) {}-> EProcess({ |e}) |_}-> EProcess({ |e})
fun pspawn(f) {
    do Spawn(f)
}

# Process suspension
sig yield : () {Yield:() |_}-> ()
fun yield() { do Yield }

# Process queue
typename Queue(a::Type) = ([a],[a]);

sig emptyQueue : () -> Queue(a)
fun emptyQueue() { ([], []) }

sig isEmptyQueue : (Queue(a)) -> Bool
fun isEmptyQueue(q) {
    switch(q) {
      case ([],[])   -> true
      case otherwise -> false
    }
}

sig enqueue : (Queue(a), a) -> Queue(a)
fun enqueue((xs,ys), y) { (xs, y::ys) }

sig dequeue : (Queue(a)) ~> (a, Queue(a))
fun dequeue(q) {
    switch (q) {
      case (x :: xs, ys) -> (x, (xs, ys))
      case ([], ys)      -> dequeue((ys,[]))
    }
}

## TODO: Implement the queue as a handler

# State handler
sig evalState : (s) -> (Comp({Get:s,Put:(s) {}-> () |e}, a)) -> Comp({Get{_},Put{_} |e}, a)
handler evalState(s) {
  case Get(k)    -> k(s)(s)
  case Put(s,k)  -> k(())(s)
  case Return(x) -> x
}

sig get : () {Get:s|_}-> s
fun get() {do Get}

sig put : (s) {Put:(s) {}-> ()|_}-> ()
fun put(s) {do Put(s)}

# Process scheduler
fun enqueueProcess(f) {
  var q = enqueue(get(), f);
  put(q)
}

fun dequeueProcess() {
   var q = get();
   if (isEmptyQueue(q)) { fun() { () } }
   else {
      var (p, q) = dequeue(q);
      put(q);
      p
   }
}

handler process(parent, numChildren) {
  case Spawn(f,k) ->
       var childPid = makeChildPid(parent, numChildren+1);
       var child = makeProcess(f, childPid);
       enqueueProcess(fun() { k(child)(parent, numChildren+1) });
       process(child, 0)(f)()
  case Yield(k)   ->
       enqueueProcess(fun() { k(())(parent, numChildren) });
       dequeueProcess()()
  case MyPid(k) -> k(getPid(parent))(parent, numChildren)
  case Return(_)  ->
       dequeueProcess()()
}

fun hello(depth)() {
    if (depth == 0) { () }
    else {
         print("Hello from process #" ^^ pidToString(myPid()));
         var _ = pspawn(hello(depth-1));
         #yield();
         var _ = pspawn(hello(depth-1));
         ()
    }
}

# Example
op h -<- g { fun(m) { h(g(m)) } }
op h -< m  { h(m) }

fun run(m) { m() }

var dummy = run -<- evalState(emptyQueue()) -<- process(makeProcess(fun() { () }, "0"), 0) -< hello(4);

# Communication
sig psend : (EProcess({ |e}), a) {Send:(Pid, a) {}-> (),Yield:()|_}-> ()
fun psend(proc, msg) { do Send(getPid(proc), msg); yield() }

op proc $! msg { psend(proc, msg) }

sig precv : () {Recv:(Pid) {}-> Maybe(a),MyPid:Pid,Yield:()|_}~> a
fun precv() {    
    fun loop(mypid : Pid) {
       var msg = do Recv(mypid);
       yield();
       switch (msg : Maybe(a)) {
         case Nothing   -> loop(mypid)
	 case Just(msg) -> msg
       }
    }
    loop(myPid())
}

typename Ordering = [|GT
                     |EQ
                     |LT
                     |];

typename Comparer(a::Type,e::Row) = (a,a) ~e~> Ordering;

typename Colour = [|Red|Black|BlackBlack|];

typename RedBlackSet(a::Type) = [|Empty
                                 |EmptyEmpty
                                 |Node:(Colour,RedBlackSet(a),a,RedBlackSet(a))
                                 |];

sig rbEmpty : () -> RedBlackSet(a)
fun rbEmpty() { Empty }

sig rbMember : (a, RedBlackSet(a), (a,a) ~e~> Ordering) ~e~> Bool
fun rbMember(x, rb, cmp) {
    switch (rb) {
      case Empty -> false
      case Node(_,l,y,r) ->
         switch (cmp(x,y)) {
           case LT -> rbMember(x, l, cmp)
           case EQ -> true
           case GT -> rbMember(x, r, cmp)
         }
      case _ -> error("Impossible case rbMember")
    }
}

sig rbBalance : ((Colour, RedBlackSet(a), a, RedBlackSet(a))) -> RedBlackSet(%b)
fun rbBalance(node) {
    switch (node) {
      case (Black, Node(Red, Node(Red, a, x, b), y, c), z, d) -> Node(Red, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case (Black, Node(Red, a, x, Node(Red, b, y, c)), z, d) -> Node(Red, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case (Black, a, x, Node(Red, Node(Red, b, y, c), z, d)) -> Node(Red, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case (Black, a, x, Node(Red, b, y, Node(Red, c, z, d))) -> Node(Red, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case (BlackBlack, a, x, Node(Red, Node(Red, b, y, c), z, d)) -> Node(Black, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case (BlackBlack, Node(Red, a, x, Node(Red, b, y, c)), z, d) -> Node(Black, Node(Black, a, x, b), y, Node(Black, c, z, d))
      case body                                               -> Node(body)
    }
}

sig rbInsert : (a, RedBlackSet(a), (a,a) ~e~> Ordering) ~e~> RedBlackSet(a)
fun rbInsert(x, rb, cmp) {
   fun ins(rb) {
     switch (rb) {
       case Empty -> Node(Red, Empty, x, Empty)
       case (Node(colour, a, y, b) as rb) ->
          switch (cmp(x, y)) {
             case LT -> rbBalance((colour, ins(a), y, b))
             case EQ -> rb
             case GT -> rbBalance((colour, a, y, ins(b)))
          }
       case _     -> error("Impossible case rbInsert")
     }
   }
   switch (ins(rb)) {
     case Node(_, a, y, b) -> Node(Black, a, y, b)
     case _                -> error("Impossible case ins")
   }
}

fun rbRotate(colour, left, x, right) {
  switch ((colour, left, x, right)) {
     case (Red, Node(BlackBlack, a, x, b), y, Node(Black, c, z, d)) -> rbBalance((Black, Node(Red, Node(Black, a, x, b), y, c), z, d))
     case (Red, EmptyEmpty, y, Node(Black, c, z, d)) -> rbBalance((Black, Node(Red, Empty, y, c), z, d))
     case (Red, Node(Black, a, x, b), y, Node(BlackBlack, c, z, d)) -> rbBalance((Black, a, x, Node(Red, b, y, Node(Black, c, z, d))))
     case (Red, Node(BlackBlack, a, x, b), y, Node(Black, c, z, d)) -> rbBalance((BlackBlack, Node(Red, Node(Black, a, x, b), y, c), z, d))
     case (Black, Node(BlackBlack, a, x ,b), y, Node(Black, c, z, d)) -> rbBalance((BlackBlack, Node(Red, Node(Black, a, x, b), y, c), z, d))
     case (Black, EmptyEmpty, y, Node(Black, c, z, d)) -> rbBalance((BlackBlack, Node(Red, Empty, y, c), z, d))
     case (Black, Node(Black, a, x, b), y, Node(BlackBlack, c, z, d)) -> rbBalance((BlackBlack, a, x, Node(Red, b, y, Node(Black, c, z, d))))
     case (Black, Node(Black, a, x, b), y, EmptyEmpty) -> rbBalance((BlackBlack, a, x, Node(Red, b, y, Empty)))
     case (Black, Node(BlackBlack, a, w, b), x, Node(Red, Node(Black, c, y, d), z, e)) ->
       Node(Black, rbBalance((Black, Node(Red, Node(Black, a, w, b), x, c), y, d)), z, e)
     case (Black, EmptyEmpty, x, Node(Red, Node(Black, c, y, d), z, e)) -> Node(Black, rbBalance((Black, Node(Red, Empty, x, c), y, d)), z, e)
     case (Black, Node(Red, a, w, Node(Black, b, x, c)), y, EmptyEmpty) -> Node(Black, a, w, rbBalance((Black, b, x, Node(Red, c, y, Empty))))
     case (colour, a, x, b) -> Node(colour, a, x, b)
  }
}

fun rbDelete(x, rb, cmp) {

   fun min_del(rb) {
      switch(rb : RedBlackSet(a)) {
        case Node(Red, Empty, x, Empty)   -> (x, Empty)
        case Node(Black, Empty, x, Empty) -> (x, EmptyEmpty)
        case Node(Black, Empty, x, Node(Red, Empty, y, Empty)) -> (x, Node(Black, Empty, y, Empty))
        case Node(c, a, x, b) ->
           var (y, d) = min_del(a);
           (y, rbRotate(c, d, x, b))
        case _ -> error("Impossible case min_del")
      }
   }
   
   fun del(rb) {
      switch(rb : RedBlackSet(a)) {
        case Empty -> Empty
        case Node(Red, Empty, y, Empty) ->
           switch(cmp(x, y)) {
              case EQ        -> Empty
              case otherwise -> Node(Red, Empty, y, Empty)
           }
        case Node(Black, Empty, y, Empty) ->
           switch(cmp(x, y)) {
              case EQ         -> EmptyEmpty
              case otherwise  -> Node(Black, Empty, y, Empty)
           }
        case Node(Black, Node(Red, Empty, y, Empty), z, Empty) ->
           switch(cmp(x, z)) {
              case LT -> Node(Black, del(Node(Red, Empty, y, Empty)), z, Empty)
              case EQ -> Node(Black, Empty, y, Empty)
              case GT -> Node(Black, Node(Red, Empty, y, Empty), z, Empty)
           }
        case Node(c, a, y, b) ->
           switch(cmp(x, y)) {
              case LT -> rbRotate(c, del(a), y, b)
              case EQ ->
                var (z,d) = min_del(b);
                rbRotate(c, a, z, d)
              case GT -> rbRotate(c, a, y, del(b))
           }
        case _ -> error("Impossible case del")
      }
   }
   fun redden(rb) {
      switch(rb : RedBlackSet(a)) {
         case Node(Black, Node(Black, a, x ,b), y, Node(Black, c, z, d)) -> Node(Red, Node(Black, a, x ,b), y, Node(Black, c, z, d))
         case t -> t
      }
   }
   del(redden(rb))   
}

sig rbReplace : (a, a, RedBlackSet(a), Comparer(a, { |e})) ~e~> RedBlackSet(a)
fun rbReplace(x, y, rb, cmp) {
    # delete x
    # insert y
    error("Not yet implemented.")
}
