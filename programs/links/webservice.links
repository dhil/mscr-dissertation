#
# Development of a small web-service using handlers
#
# Messaging service API? Name: jibber-jabber? Chitter (Cheep)?

# Modelling a http method
typename Method      = [|Get|Put|Post|Delete|];
typename Resource    = (name:String,member:String,params:[(String,String)]);
typename Researcher  = (title:String, name:String, dpt:String, pubs:[Publication]);
typename Publication = String;

# Basic operations
sig get : (r) {Get:(r) {}-> s|_}~> s
fun get(r) server {do Get(r)}

sig put : (r) {Put:(r) {}-> ()|_}~> ()
fun put(r) server {do Put(r)}

sig post : (r) {Post:(r) {}-> ()|_}~> ()
fun post(r) server {do Post(r)}

sig remove : (r) {Delete:(r) {}-> ()|_}~> ()
fun remove(r) server {do Delete(r)}


# Serve a request
sig serve : (Method,String) {Serve:(Method,String) {}-> a}~> a
fun serve(m,r) server {do Serve(m,r)}

sig hello : (Comp({Serve:(Method,String) {}-> String}, a)) ~> a
fun hello(m) server {
  handle(m) {
    case Return(x)  -> x
    case Serve(Get,_,k) -> k("<string>Hello World</string>")
    case Serve(_,_,k)  -> k("Unsupported operation.")
  }
}

# Failure handler
sig fail : () {Fail:Zero|_}~> _
fun fail() server {switch (do Fail) { }}

sig maybe : (Comp({Fail:_|e},a)) -> Comp({Fail{_}|e}, Maybe(a))
fun maybe(m)() server {
  open handle(m) {
    case Fail(_)   -> Nothing
    case Return(x) -> Just(x)
  }
}

# Handle get
sig getter : (Comp({Get:(Maybe(String)) {}-> String|e}, a)) ->
              Comp({Get{_}                         |e}, a)
fun getter(m)() server {
  open handle(m) {
    case Return(x)      -> x
    case Get(Just(r),k) -> k(r)
    case Get(_,k)       -> k("No resource")
  }
}

sig run : (Comp({}, a)) ~> a
fun run(m) server {
  handle(m) { case Return(x) -> x }
}

sig handleRequest : () ~> String
fun handleRequest() server {
  #hello(fun() { serve(getMethod(), "asd") })
  var response = run -<- maybe -<- getter -< fun () {
    switch (getMethod()) {
      case Get -> get(getParam("resource"))
      case _   -> "Unsupported method"
    }
  };
  switch (response) {
    case Just(r) -> r
    case _       -> "500 Internal Error"
  }
}

# database queries
sig getAll : () ~> [Researcher]
fun getAll() {
  [ mkResearcher("PhD-student", "Daniel HillerstrÃ¶m", "CDT Pervasive Parallelism", [])
  , mkResearcher("Dr",          "Sam Lindley",        "Laboratory for Foundations of Computer Science", [])
  , mkResearcher("Professor",   "Philip Wadler",      "Laboratory for Foundations of Computer Science", [])
  , mkResearcher("Associate Professor", "Christophe Dubach", "Institute for Computing Systems and Architecture", [])
  ]
}

# Main page
#         {stringToXml(jsonifyL(getAll())(jsonifyR))}
sig main : () ~> Page
fun main() client {
  page
   <html>
    <head>
      <title>Small web-service example</title>
    </head>
    <body>
        {stringToXml(handleRequest())}     

      <fieldset>
       <legend>Debug info</legend>
       <ul>
        <li>Environment size: {intToXml(length(environment()))}</li>
       </ul>
      </fieldset>
    </body>
    </html>
}

# Server-side auxiliary functions
# Retrieves the value associated with a given url parameter name
sig getParam : (String) ~> Maybe(String)
fun getParam(p) server { lookup(p, environment()) }

sig getMethod : () ~> Method
fun getMethod() server {
  switch (getParam("method")) {
    case Just(m) ->
       switch (implode(map(toLower, explode(m)))) {
         case "post"   -> Post
         case "put"    -> Put
         case "delete" -> Delete
         case "get"    -> Get
         case _        -> Get
       }
    case _ -> Get
  }
}

# Weak equality on strings aka. case-insensitive equality testing
sig ~= : (String,String) ~> Bool
op p ~= q {
  fun lower(s) { implode(map(toLower,explode(s))) }
  lower(p) == lower(q)
}

# Maybe monad
sig >>= : (Maybe(a), (a) -e-> Maybe(b)) -e-> Maybe(b)
op m >>= f {
  switch (m) {
    case Just(x) -> f(x)
    case Nothing -> Nothing
  }
}

sig return : (a) -> Maybe(a)
fun return(x) { Just(x) }

# splits on `sep`
fun splitOn(sep, xs) {
  var s = elemIndex(sep, xs) >>=
            fun(i) { return( (take(i, xs), drop(i, xs)) ) };
  switch (s) {
    case Just((xs,ys)) -> xs :: splitOn(sep, ys)
    case Nothing       -> [xs]
  }
}

# Parses a resource string
sig parseResource : (String, [(String,String)]) ~> Maybe(Resource)
fun parseResource(r, ps) {
   if (r =~ /^[a-z]+\/[a-z]+$/) {
     
   } else { Nothing }
}

# Parses the current request
sig getRequest : () ~> Maybe(Resource)
fun getRequest() {
  var ps =
     filter( fun((k,_) { not(k ~= "method" || k ~= "resource") }
           , environment()); # filters out "special" parameters
  var method = getMethod();
  # Build Resource
  getParam("resource") >>=
     fun(r) { return( (name=r) ) } >>=
        fun (r) {
  
}

fun mkResearcher(title, name, department, publications) {
  (title=title, name=name,dpt=department,pubs=publications)
}

sig jsonifyL : ([a]) -> ((a) ~e~> String) ~e~> String
fun jsonifyL(xs)(formatter) {
  var xs = map(formatter,xs);
  "[" ^^ (if (length(xs) > 0)
           fold_left(fun(acc, x) { acc ^^ "," ^^ x }, hd(xs), tl(xs))
         else "")
   ^^ "]"
    
}

sig jsonifyR : (Researcher) ~> String
fun jsonifyR(r) {
  "{\"title\": \"" ^^ r.title ^^"\"" ^^
  ",\"name\": \"" ^^ r.name ^^ "\""  ^^
  ",\"dpt\": \"" ^^ r.dpt ^^ "\"" ^^
  ",\"pubs\": " ^^ jsonifyL([])(fun(_) { "" }) ^^ "}"
}


# Run example
main()
