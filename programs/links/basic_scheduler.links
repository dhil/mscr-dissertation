# Basic scheduler

# Primitives
sig fork : (a) {Fork:(a) {}-> b|_}~> b
fun fork(t) {do Fork(t)}

sig yield : Comp({Yield:()|_}, ())
fun yield() {do Yield}

# Run handler
sig run : (Comp({},a)) {}~> a
handler run { case Return(x) -> x }

#
# Queue interface
#
typename Queue(a::Type) = [a];

sig enqueue : (a) {Enqueue:(a) {}-> ()|_}~> ()
fun enqueue(e) {do Enqueue(e)}

sig dequeue : Comp({Dequeue:a|_}, a)
fun dequeue() {do Dequeue}

sig is_empty : Comp({IsEmpty:Bool|_}, Bool)
fun is_empty() {do IsEmpty}

sig size : Comp({Size:Int|_},Int)
fun size() {do Size}

# Fair queue implementation
sig queue : (Queue(a)) ->
                  (Comp({Dequeue:Maybe(a) ,Enqueue:(a) {}-> ()|e}, b)) -> 
                   Comp({Dequeue{_},Enqueue{_}         |e}, b)
open handler queue(q) {
  case Enqueue(e,k) -> k(())(q ++ [e])
  case Dequeue(k)   ->
    if (length(q) == 0) k(Nothing)(q)
    else k(Just(hd(q)))(tl(q))
  case Return(x)    -> x
}

# Scheduler
typename Worker = forall e :: Row . () ~e~> ();
typename Thread(e::Row,a) = (() {Fork:(Thread(e,a)) {}-> (),Yield|e}~> a);
#typename Suspended(e::Row,a) = (_) { |e}~> a

# (mu t . ((()) {Fork{_},Enqueue:t,Dequeue:a,Yield{_}|e}~> a))
#sig scheduler : (Comp({Fork:(Thread({  |e1}, a)),Yield
#                       Enqueue:(mu t . ((()) {Fork{_},Enqueue:t,Dequeue:Maybe(t),Yield{_}|e}~> a)),Dequeue:Maybe(t)|e2}, a) ->
#                 Comp({Fork{_},Yield{_},
#                       Enqueue:(mu t . ((()) {Fork{_},Enqueue:t,Dequeue:Maybe(t),Yield{_}|e}~> a)),Dequeue:Maybe(t)|e2}, a)
#open handler scheduler {
#  case Fork(t,k) -> enqueue(fun (_) { k(()) }); scheduler(t)()
#  case Yield(k)  -> enqueue(fun (_) { k(()) }); var t = dequeue(); fromJust(t)(())
#  case Return(x) ->
#     var e = dequeue();
#     switch (e) {
#       case Just(t) -> t(())
#       case _       -> x
#     }
#}
#sig simple : (mu a . (() {Enqueue:((b) {Enqueue:((b) { |c}~> d) {}-> ()
#                                               ,Fork{e}|f}~> d) {}-> ()
#                         ,Fork:(a) {}-> ()|f}~> d)) ->
#                      () {Enqueue:((b) {Enqueue:((b) { |c}~> d) {}-> ()
#                                               ,Fork{e}|f}~> d) {}-> ()
#                         ,Fork{e}|f}~> d
#sig simple : (mu a . (Comp({ |a}, b))) { |e2}~> b
#fun simple(_) { switch (error("")) { } }                         
#               () {Enqueue:(mu h . ((b) {Enqueue:((b) { |h}~> d) {}-> ()
#                                         ,Fork{e}|f}~> d)) {}-> ()
#                  ,Fork{e}|f}~> d

typename Scheduler = (Comp({Fork:(Thread({},())) {}-> ()}, ())) -> ();

open handler simple {
  case Fork(t,k) -> enqueue(fun (_) { k(()) }); simple(t)()
  case Return(x) -> x
}

fun repeat(r)(f) {
  var x = f();
  if (r > 1) repeat(r-1)(f) else x
}

# Example
sig worker : (Int) -> Worker
fun worker(id)() {
  print("Hello from worker " ^^ intToString(id));
  var _ = yield();
  ()
}

#sig hello : Thread({Fork:(() {Yield|_}~> ()) {}-> ()|_}, ())
sig hello : Thread({ |e2}, ())
fun hello() {
  var _ = fork(fun() { repeat(5)(worker(1)) });
  var _ = fork(fun() { repeat(5)(worker(2)) });
  ()
}
