%% Master by Research, CDT PPAR, print twosided, new chapters on right page
\documentclass[mscres,cdtppar,twoside,openright,logo,rightchapter,normalheadings]{infthesis}
\shieldtype{0}

%% Packages
\usepackage[utf8]{inputenc}   % Enable UTF-8 typing
\usepackage[british]{babel}   % British English
\usepackage[breaklinks]{hyperref}         % Interactive PDF
\usepackage{url}
\usepackage{breakurl}
\usepackage{amsmath}          % Mathematics library
\usepackage{amssymb}          % Provides math fonts
\usepackage{amsthm}           % Provides \newtheorem, \theoremstyle, etc.
\usepackage{mathpartir}       % Inference rules
\usepackage{array}
\usepackage{float}            % Float control
\usepackage{caption,subcaption}  % Sub figures support
\usepackage[T1]{fontenc}      % Fixes font issues
\usepackage{lmodern}
\usepackage{enumerate}        % Customise enumerate-environments
\usepackage{xcolor}           % Colours
\usepackage{drawstack}        % Syntactic sugar for using tikz to draw run-time stacks

% Drawing
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary{calc}  
\usetikzlibrary{fit}
\usetikzlibrary{shapes}

% Bibliography
\usepackage{natbib}
\setcitestyle{authoryear,open={(},close={)}}
% \usepackage[
% backend=bibtex,
% style=numeric,
% sorting=nyt
% ]{biblatex}  
% \addbibresource{references.bib}

% Source code listings
\usepackage{xcolor}
\usepackage{listings}

\lstset{
 backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
 basicstyle=\ttfamily\small,        % the size of the fonts that are used for the code
 commentstyle=\itshape,
 breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
 breaklines=true,                 % sets automatic line breaking
 captionpos=b,                    % sets the caption-position to bottom
 deletekeywords={...},            % if you want to delete keywords from the given language
 escapeinside={§*}{*§},          % if you want to add LaTeX within your code
 extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
 frame=none,	                   % adds a frame around the code
 keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
 numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
 rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
 showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
 showstringspaces=false,          % underline spaces within strings only
 showtabs=false,                  % show tabs within strings adding particular underscores
 tabsize=2,	                   % sets default tabsize to 2 spaces
 title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  belowcaptionskip=-1\baselineskip,
  xleftmargin=\parindent
}

\definecolor{darkgreen}{rgb}{0.000000,0.392157,0.000000}
\definecolor{violetred}{rgb}{0.915686,0.125490,0.364706}

% Define Links as a lst-language
\lstdefinelanguage{Links}{% 
  morekeywords={typename, fun, op, var, if, this, true, false, else, case, switch, handle, handler, shallowhandler, do, sig},%
  sensitive=t, % 
  keywordstyle=\color{red},
  emph={Comp,Player,Bool,Int,GTree,Cheat,Zero,Choose,Rand,Move,Winner,Take,Return,Get,Put,GameState,Alice,Bob,Fail,Nothing,Just,Maybe,Toss,Heads,Tails},
  emphstyle={\color{blue}},
  comment=[l]{\#},% 
  commentstyle={\itshape\color{green}},%
  escapeinside={(*}{*)},%
  morestring=[d]{"}%
 }

% Haskell style
\lstdefinestyle{haskell}{
  language=Haskell,
  basicstyle=\linespread{1.0}\ttfamily\footnotesize,
  literate= {+}{{$+$}}1 {*}{{$*$}}1
            {<=}{{$\leq$}}1 {/=}{{$\neq$}}1 
            {==}{{$\equiv$}}1 {=>}{{$\Rightarrow$}}1
            {->}{{$\to$}}1 {<-}{{$\leftarrow$}}1
            {.}{{$\circ$}}1 {$$}{{\$}}1
}
% Ocaml style
\lstdefinestyle{ocaml}{
  language=Caml,%
  morekeywords={effect, perform},%
  emph={Obj,Choose},%
%  literate= {+}{{$+$}}1 {*}{{$*$}}1
%            {<=}{{$\leq$}}1 {>=}{{$\geq$}}1 {<>}{{$\neq$}}1 
%            {==}{{$\equiv$}}1 {=>}{{$\Rightarrow$}}1
%            {->}{{$\to$}}1
}

\newcommand{\textapprox}{{\fontfamily{ptm}\selectfont\texttildelow}}
\newcommand{\wildarrow}{\linksify{\textapprox{}>}}
% Links style
\lstdefinestyle{links}{
  caption={},
  basicstyle=\linespread{1.0}\ttfamily\footnotesize,
  language=Links,
  literate= {~>}{{\wildarrow}}1
}

\lstset{style={links}}



% Theorem environments
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}

% Example environment
\makeatletter  
\def\@endtheorem{\qed\endtrivlist\@endpefalse } % insert `\qed` macro
\makeatother
\theoremstyle{definition}
\newtheorem{example}{Example}[chapter]

%% Utilities
% TODOs
\newcommand{\todo}[1]{{\par\noindent\small\color{red} \framebox{\parbox{\dimexpr\linewidth-2\fboxsep-2\fboxrule}{\textbf{TODO:} #1}}}}

% Convenient macros
\newcommand{\linksify}[1]{\texttt{#1}}
\newcommand{\defas}[0]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}} % "defined-as-equal"
\newcommand{\rulesep}{\unskip\ \vrule\ } % Inserts a vertical line

% Formalisation
%\newcommand{\Calc}{\ensuremath{\lambda_{\text{effrow}}}\xspace}
\newcommand{\Calc}{\ensuremath{\lambda_{\text{eff}}^\rho}\xspace}

\newcommand{\slab}[1]{\textrm{#1}}
\newcommand{\semlab}[1]{\text{\scshape{S-#1}}}
\newcommand{\tylab}[1]{\text{\scshape{T-#1}}}
\newcommand{\mlab}[1]{\text{\scshape{M-#1}}}
\newcommand{\klab}[1]{#1}
\newcommand{\revto}{\ensuremath{\leftarrow}}

\newcommand{\keyw}[1]{\textbf{#1}}
\newcommand{\Handle}{\keyw{handle}}
\newcommand{\With}{\keyw{with}}
\newcommand{\Let}{\keyw{let}}
\newcommand{\In}{\keyw{in}}
\newcommand{\Do}{\keyw{do}}
\newcommand{\Return}{\keyw{return}}
\newcommand{\Case}{\keyw{case}}
\newcommand{\Absurd}{\keyw{absurd}}
\newcommand{\Record}[1]{\ensuremath{\langle #1 \rangle}}

\newcommand{\Pre}[1]{\mathsf{Pre}(#1)}
\newcommand{\Abs}{\mathsf{Abs}}
\newcommand{\Presence}{\mathsf{Presence}}
\newcommand{\Row}{\mathsf{Row}}
\newcommand{\Type}{\mathsf{Type}}

\newcommand{\Int}{\mathsf{Int}}
\newcommand{\Bool}{\mathsf{Bool}}

\newcommand{\True}{\mathsf{true}}
\newcommand{\False}{\mathsf{false}}

\newcommand{\cek}[1]{\ensuremath{\langle #1 \rangle}}

% configurations
\newcommand{\conf}{\mathcal{C}}

% typing
%% \newcommand{\eff}{\mathbin{!}}
\newcommand{\eff}{!}
\newcommand{\typ}[2]{#1 \vdash #2}
\newcommand{\typv}[2]{#1 \vdash #2}
\newcommand{\typc}[3]{#1 \vdash #2 \eff #3}

\newcommand{\harrow}[2]{\ensuremath{\mathbin{~^{#1}\!\!\Rightarrow^{#2}}}}
%\newcommand{\Harrow}[4]{#1 \harrow{#2}{#4} #3}
\newcommand{\Harrow}[4]{#1!#2 \Rightarrow #3!#4}

% stacks
\newcommand{\nil}{\ensuremath{[\,]}}
\newcommand{\cons}{\ensuremath{::}}

% These operators are taken from Conor's Agda course:
%   * fish appends a cons list onto a snoc list by reversing the cons list
%     (yielding a snoc list)
%   * chips appends a cons list onto a snoc list by reversing the snoc list
%     (yielding a cons list)
%   * chips is revapp (assuming we represent snoc lists as cons lists)
\newcommand{\fish}{\ensuremath{\mathbin{<\!>\!\!<}}}
\newcommand{\chips}{\ensuremath{\mathbin{<\!>\!\!>}}}

%\newcommand{\revapp}{\ensuremath{\mathbin{<\!\!\!+\!\!+}}}
\newcommand{\revapp}{\chips}

\newcommand{\concat}{\mathbin{+\!\!+}}


%% Effects on the turnstyle
%\newcommand{\typ}[3]{#1 \vdash_{#3} #2}


% environments
\newcommand{\env}{\gamma}

\newcommand{\reducesto}[0]{\ensuremath{\leadsto}}
\newcommand{\stepsto}[0]{\ensuremath{\longrightarrow}}
\newcommand{\Stepsto}{\Longrightarrow}

% array stuff
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bl}{\ba[t]{@{}l@{}}}
\newcommand{\el}{\ea}

% Syntax environment
\newenvironment{syntax}{\[\ba{@{}l@{\quad}r@{~}c@{~}l@{}}}{\ea\]\ignorespacesafterend}
\newenvironment{reductions}{\[\ba{@{}l@{\qquad}@{}r@{~~}c@{~~}l@{}}}{\ea\]\ignorespacesafterend}

\newenvironment{eqs}{\ba{@{}r@{~}c@{~}l@{}}}{\ea}
\newenvironment{equations}{\[\ba{@{}r@{~}c@{~}l@{}}}{\ea\]\ignorespacesafterend}


% translations
\newcommand{\val}[2]{\llbracket #1 \rrbracket #2}
\newcommand{\inv}[1]{\llparenthesis #1 \rrparenthesis}

% restrict an environment
\newcommand{\res}{\backslash}

%% Information about the title, etc.
\title{Compilation of Effect Handlers and their Applications in Parallelism}
\author{Daniel Hillerström}

%% If the year of submission is not the current year, uncomment this line and 
%% specify it here:
\submityear{2016}

%% Specify the abstract here.
\abstract{%
  \todo{Refine abstract} 
%
  Applications are comprised of \emph{effectful operations}, such as
  raising exceptions, thread forking, writing and reading from files
  or updating mutable state.  Often effectful operations have a
  salient impact on the behaviour of an application. Yet in many
  programming models such operations subsist as uncontrollable
  side-effecting actions, that occur implicitly on ``the side'' during
  run-time.

%
Algebraic effects combined with effect handlers provide an interface for controlling effectful operations.

% 
  Many programs comprise effectful operations such as thread forking,
  raising exceptions, writing and reading from files or updating some
  mutable state.  have a salient impact on the behaviour of programs.
  During run-time programs may perform several side-effecting
  actions. Effects are a salient part of Programs Algebraic effects
  combined with effect handlers provide a modular abstraction for
  effectful programming.
%
Concurrency and parallelism 
%%
The key insight is to classify handlers according to their linearity.
%%

We present a core calculus \Calc{} with row-polymorphic effects and affine handlers based on a variation of A-normal form used in our implementation. In addition, we give an operational semantics for the calculus, which we use to prove the soundness of the calculus.
}

%% Now we start with the actual document.
\begin{document}
\raggedbottom
%% First, the preliminary pages
\begin{preliminary}

%% This creates the title page
\maketitle

%% Acknowledgements
\begin{acknowledgements}
Acknowledgements will appear here\dots

Thanks Christophe\dots

Thanks Sam\dots

Thanks Office 1.07\dots

Thanks OCaml Labs and KC\dots

Thanks to Caoimhín Laoide-Kemp\dots

This work was supported in part by the EPSRC Centre for Doctoral Training in Pervasive Parallelism, funded by the UK Engineering and Physical Sciences Research Council (grant EP/L01503X/1) and the University of Edinburgh.
\end{acknowledgements}

%% Next we need to have the declaration.
\standarddeclaration

%% Finally, a dedication (this is optional -- uncomment the following line if
%% you want one).
%\dedication{To my mummy.}

\begin{preface}
A preface will possibly appear here\dots
\end{preface}

%% Create the table of contents
\setcounter{secnumdepth}{2} % Numbering on sections and subsections
\setcounter{tocdepth}{3} % Show chapters, sections and subsections in TOC
%\singlespace
\tableofcontents
%\doublespace

%% If you want a list of figures or tables, uncomment the appropriate line(s)
% \listoffigures
% \listoftables
\end{preliminary}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%          Main content         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% Introduction
%%
\chapter{Introduction}
\label{ch:introduction}

For more than a decade the \emph{free lunch} has been over
\citep{Sutter2005}. Free lunch is a euphemism for the precursory
improvement in software application performance due to the rapid
growth of processor clock frequencies. However, the growth has
stagnated due to physical limitations \citep{Sutter2005}.
%
Nowadays we have \emph{multicore} processors. A multicore processor
comprises multiple computational cores that execute
simultaneously. Unfortunately, software applications must be designed
to take advantage of the additional processing power offered by
multicore processors. As a consequence we no longer get our lunch for
free.

%

% For more than a decade the \emph{free lunch} has been over
% \citep{Sutter2005}. The saying ``free lunch'' refers to the regular
% increase in performance, that software developers enjoyed without
% having to rewrite their applications, due to the regular increase in
% processing power as processor clock frequencies doubled every other
% year.

%

With the emergence of multicore processors parallelism has become
pervasive. As a result we are faced with the challenge of
\emph{parallel programming}. The aim of parallel programming is to
maximise program efficiency by utilising multiple computational cores
simultaneously.
%
An essential component of parallel programming is decomposition of a
program into tasks that can be run simultaneously on multiple
cores. Those tasks must then be scheduled across the available
computational resources.  Thread and process schedulers govern how the
computational resources of multicore processors are deployed. However,
compilers for most mainstream programming languages come with a
definitive scheduler that is hard wired into a complex, monolithic
runtime system.


% parallel programming is well-poised to become a dominant
% programming discipline that every software developer ought to know and
% master. But, conventional programming language are ill-suited for the
% challenge poised by parallel programming.

%

% While we continue to enjoy an increase in processing power, we do not
% get have our lunch for free anymore as clock frequencies no longer
% rise, which is mainly due to physical issues such as excessive heat,
% power consumption, and current leakage problems
% \citep{Sutter2005}. Instead a single computational device now comprise
% multiple processing cores. Consequently, we are faced with the
% challenge of \emph{parallel programming}, i.e.  programming multiple
% processing cores to execute simultaneously. Existing programs must be
% rewritten in order to take advantage of multiple cores, and hence,
% performance no longer increases for free.

%

In this work we adopt an approach akin to Multicore OCaml
\citep{Dolan2014,Dolan2015} by using \emph{handlers for algebraic
  effects} \citep{Plotkin2001,Plotkin2003,Plotkin2013} to enable
programmers to write user-level, modular schedulers along the lines of
\citet{KC2016}. Our story is twofold: we study novel applications of
effect handlers in parallelism, as well as presenting a novel
compilation technique for effect handlers.

%

% In this work, we shall consider \emph{handlers for algebraic effects}
% \citep{Plotkin2001,Plotkin2003,Plotkin2013} as an approach to
% concurrent and parallel programming. Our story is twofold: We study
% novel process-oriented applications of effect handlers in concurrent
% and parallel programming, but we also present a novel compilation
% technique for effect handlers.

\section{Problem analysis}

\todo{Parallelism is multiplicity of processors simultaneously}
%
\todo{Unit of concurrency: Fibers} \todo{Unit of parallelism: Domains}
%
\todo{Don't conflate concurrency and parallelism; context switching
  brings death to scaling}
%
\todo{Map fibers onto domains ($\#domains \approx \#cores$)}
Parallelism is simultaneous execution
%
of computations. Concurrency is overlapped execution of processes.
Parallelism is about utilising multiple computational resources
simultaneously to maximise efficiency. The aim is speed up a
computation by delegating different parts of it to different
processors to execute at the same time \citep{Marlow2013}.

By contrast, concurrency is concerned with structuring interactions
between multiple agents. Conceptually, 

% In theory,
% parallelism is easy, since running any two sequential programs in
% parallel have the same semantics as running them sequentially. In
% practice, though, parallelism is often hard because we have far more
% computations to delegate than we have available resources, thus we
% must carefully \emph{schedule} computations.


\section{Problem statement}
\section{Aims and objectives}
Our main contributions are
\begin{itemize}
  \item A compiler for Links with effect handlers, that supports the
    full abstraction provided by deep handlers making novel use of the
    existing linear type system of Links to guide the code generator for
    handlers.
  \item A reconstruction of the message-passing concurrency model of
    Links in terms of effect handlers. 
  \item Novel applications of effect handlers in parallelism.
\end{itemize}
\section{Thesis outline}
\section{Typographical conventions}

%%
%% Related work
%%
\chapter{Related work}
\label{ch:related-work}

\section{Implementations of effect handlers}
Any signature of abstract operations can be understood as a free
algebra and represented as a functor. In particular, every such
functor gives rise to a free monad. Thus, free monads provide a
natural basis for implementing effect handlers (\citet{Swierstra2008b}
provide an account of free monads for functional programmers).  Many
of the library implementations of effect handlers include
implementations based on free monads~\citep{Kammar2013, Kiselyov2013,
  Kiselyov2015, Brady2013, Wu2014}.

\citet{Kammar2013} provide an implementation of effect handlers using
a continuation monad, which completely avoids materialising any data
constructors. \citet{Wu2015} explain how it works, by taking advantage
of Haskell's fusion optimisations. This approach does appear to depend
rather critically on the handlers being deep rather than shallow, and
in Haskell it relies on them being type classes, and hence not really
first class.

The Idris effects library by \cite{Brady2013} takes advantage of
dependent types to provide effect handlers for a form of effects
corresponding to parameterised monads~\citep{Atkey09}.
%
In the effects library, effects are represented as lists of types.

We are aware of three languages that are specifically designed with
effect handlers in mind.
%
\begin{itemize}
\item The Eff language by \cite{Bauer2015} is a strict language with
  Hindley-Milner type inference similar in spirit to ML, but extended
  with effect handlers.
%
It includes a novel feature for supporting fresh generation of effects
in order to support effects such as ML-style higher-order state (which
has an operation for generating new references).
%
The original version of Eff~\citep{Bauer2015} does not include an
effect type system. However, an effect type system has subsequently
been experimented with~\citep{BauerP13, Pretnar2014}.
%
This effect type system is considerably more complicated than ours. It
makes essential use of subtyping, includes a region system, and a form
of effect polymorphism, which one might reasonably cast as a form of
row polymorphism.

\item Frank by \cite{McBride2014} takes the idea of effect handlers to
  the extreme, having no primitive notion of function, only
  handlers. In Frank a function is but a special case of a handler.
  Frank is built on a bidirectional type system. It includes an effect
  type system and a novel form of effect polymorphism in which the
  programmer never needs to read or write any effect
  variables. Frank's effect system can be viewed as implementing a
  form of row polymorphism. Unlike Links, but much like
  Koka by \cite{Leijen14}, Frank allows multiple occurrences of the same
  label in a row. In contrast rows in Links are based on Remy's design
  in which duplicates are not allowed, but negative information is.

\item Shonky by \cite{McBride2016} amounts to a dynamically-typed variant
  of Frank. Though it is not statically typed, handlers must be
  annotated with the names of the effects that they handle. The
  implementation of Shonky is quite similar to ours in that it uses a
  generalisation of the CEK machine. The main differences are that
  Shonky does not use an ANF representation, so has more forms of
  continuation to handle, and in contrast to our nested continuation
  structure, Shonky uses a completely flat structure.
  % and where our continuations have a nested
  % structure, Shonky uses a completely flat structure for
  % continuations.
\end{itemize}

Although OCaml itself has no support for effect handlers, a
development branch, Multicore OCaml~\cite{Dolan2015}, does. Multicore
OCaml does not include an effect type system, and handlers are
restricted so that continuations are affine, that is, they can be
invoked at most once. This design admits a particularly efficient
implementation, as continuations need never be copied, so they can
simply be stored on the stack.

\section{Parallel programming models}
\todo{\cite{Marlow2013}}


%%
%% Background
%%

\chapter{Links, OCaml, and effect handlers}
\label{ch:background}
This chapter introduces algebraic effects and their
handlers. Specifically, in Section~\ref{sec:theory-handlers}
introduces the theory, while Sections~\ref{sec:links-handlers} and
\ref{sec:ocaml-handlers} give an introduction to programming with
effect handlers in Links and OCaml, respectively.

\section{A theory of algebraic effects and handlers}
\label{sec:theory-handlers}

\section{Links with effect handlers}
\label{sec:links-handlers}

\subsection{Structural typing}

\subsection{Affine and multi-shot effect handlers}
\label{sec:links-affine-multi}

This section provides a short primer to effect handlers in Links. The
contents of this section are largely based on
\cite{Hillerstrom2016b}. An algebraic effect is given by a signature
of \emph{abstract operations}. For example \emph{nondeterminism} is an
algebraic effect that is given by a nondeterministic choice operation
called \lstinline$Choose$. In Links, we may use this operation to
implement a coin toss:
%
\lstinputlisting{snippets/toss.links}
%
This declares an \emph{abstract computation} \lstinline$toss$, which
invokes an operation \lstinline$Choose$ using the \lstinline$do$
primitive.  The \lstinline$sig$ keyword begins a signature, which
reads: \lstinline$toss$ is a computation with effect signature
\lstinline${Choose:Bool |e}$ and return value \lstinline$Toss$, whose
constructors are \lstinline$Heads$ and \lstinline$Tails$.  Links
employs row typing to support extensible effect signatures, thus
\lstinline$e$ is an effect variable, which can be instantiated with
additional operations.

Introduction of another operation causes the effect signature to grow
accordingly. For example, if we introduce an exception operation
\lstinline$Fail : Zero$, then we can model a drunk coin toss:
%
\lstinputlisting{snippets/drunkToss.links}
%
Here \lstinline$Zero$ is the empty type, and thus the
\lstinline$switch$ pattern matching construct has no clauses.

An effect handler instantiates a subset of the operations of an
abstract computation. For example, the following handler interprets
\lstinline$Choose$ randomly:
%
\lstinputlisting{snippets/randomResult.links}
%
The signature conveys that the handler interprets the operation
\lstinline$Choose$ and leaves any other operations uninterpreted. The
notation \lstinline$Choose{_}$ denotes that the operation is
polymorphic in its presence.  The handler comprises two clauses:
\begin{enumerate}[1)]
  \item the \lstinline$Return$-clause specifies how to handle the return
    value of the computation.
  \item the \lstinline$Choose$-clause specifies how to handle a
    \lstinline$Choose$ operation. The parameter \lstinline$k$ is the
    (delimited) continuation of the operation \lstinline$Choose$ in the
    computation.
\end{enumerate}
We say that \lstinline$randomResult$ is a \emph{linear handler},
because it invokes every continuation exactly once. One possible
output of \lstinline$randomResult(toss)$ is
%
\lstinputlisting{outputs/randomResult.output}
%
Essentially, the handler interprets the computation \lstinline$toss$
as modelling a \emph{fair} coin, that is the outcomes ought to be
uniformly distributed.

Alternatively, we may define a handler for \lstinline$Choose$ that
invokes its continuation twice to enumerate every possible outcome:
%
\lstinputlisting{snippets/allResults.links}
%
Observe that the return value is lifted into a singleton list. The
\lstinline$Choose$-clause concatenates the outcomes obtained by
interpreting the operation as \lstinline$true$ and \lstinline$false$,
respectively. We say that \lstinline$allResults$ is a \emph{multi-shot
  handler}. The result obtained by \lstinline$allResults(toss)$ is
%
\lstinputlisting{outputs/allResults.output}
%

Finally, we have handlers that do not invoke continuations. These are
familiar \emph{exception handlers}. As an example consider the
following handler, which returns \lstinline$Just$ the result of the
computation or returns \lstinline$Nothing$ if the operation
\lstinline$Fail$ is performed:
%
\lstinputlisting{snippets/maybeResult.links}
%
The type system prevents invocation of the continuation in the
\lstinline$Fail$-clause, because the type \lstinline$Zero$ has zero
inhabitants. Linear and exception handlers together constitute
\emph{affine handlers}.

\section{OCaml with handlers}
\label{sec:ocaml-handlers}

\subsection{Nominal typing}

% \chapter{Background}
% \section{The Links programming language}
% \subsection{Concurrency model}
% \subsection{Programming with handlers}

% \section{Algebraic effects and handlers}
% \subsection{Algebraic effects}
% \subsection{Effect handlers}


%%
%% Concurrent programming with handlers
%%
\chapter{Concurrent programming with handlers}

%%
%% Compiling handlers
%%
\chapter{Compiling effect handlers}
We reuse most of the previous Links infrastructure. The Links frontend
is type-checked and translated into a small, typed intermediate
language in \emph{A-normal form} (ANF). The Links interpreter
implements a generalised CEK machine \cite{Hillerstrom2016}, which
interprets ANF code.

%

Our compilation strategy is to translate the Links ANF language into the OCaml
\emph{Lambda} language, which is a small, untyped lambda calculus. The OCaml
backend exposes a hierarchy of intermediate representations (IRs), where the
top representation is known as Lambda. As shown in the Figure
\ref{fig:infra-diagram}, the Lambda IR offers two different compilation
options: byte code and native code. Therefore by targeting Lambda rather than
a lower level IR, we achieve maximum flexibility as a translation into byte
code, in principle, enables us to take advantage of custom backends such as
\texttt{js\_of\_ocaml} to produce efficient JavaScript.

%

There are several semantic differences between Links and OCaml, e.g. Links
employs structural typing, whilst OCaml predominantly employs nominal typing.
In particular, Links employs row typing for effects, records, and variants,
whereas OCaml only supports row typing for the latter. Exhibiting a faithful
translation from Links to OCaml amounts to a lot of value boxing. Thus, we
target Lambda for greater flexibility and control.  We effectively subvert
OCaml's typechecker by targeting Lambda, however the translation is safe as
Links programs are already typechecked.

\begin{figure}
\centering
\begin{tikzpicture}
  \drawstruct{(4.5,2)}
  \structcell{\lstinline$do Choose$}  \coordinate (DoChoose) at (currentcell.west);
  \structcell{$\cdots$}
  \structcell{\lstinline$do Fail$} \coordinate (DoFail) at (currentcell.east);
  \structcell{\lstinline$Return-clause$}
  \structcell{\lstinline[keywordstyle=\footnotesize]$Exception handler$}
  \structcell{\lstinline$Choose-clause$} \coordinate (HandleChoose1) at (currentcell.west); \coordinate (HandleChoose2) at (currentcell.east);
  \structcell{$\cdot$} \coordinate (H1) at (currentcell.west);

  \drawstruct{(0,0)}
  \structcell{$\cdots$} \coordinate (H2) at (currentcell.east);
  \structcell{\lstinline$Return-clause$}
  \structcell{\lstinline[keywordstyle=\footnotesize]$Exception handler$}
  \structcell{\lstinline$Fail-clause$}
  \structcell{$\bot$}

%  \draw[<-] (H2) .. controls ([yshift=0cm] H2) and ([xshift=-10cm,yshift=4cm] H1) .. (H1);
  \draw (H2) edge[out=-20,in=-175,<-] (H1);
  \draw (DoChoose) edge[out=175,in=-180,->] (HandleChoose1);
  \draw (DoFail) edge[xshift=0.5cm,out=0,in=-360,->] (HandleChoose2);
\end{tikzpicture}
\caption{Representation of \lstinline$maybeResult(randomResult(drunkToss))$ at runtime.}\label{fig:rtstack}
\end{figure}

\section{Runtime Representation}
By using the OCaml backend we naturally inherit the OCaml
run-time. OCaml implements effect handlers as heap-managed stack data
structures, and as a consequence composition of handlers gives rise to
$n$-element stacks at run-time. For example, the composition
\lstinline[mathescape]!randomResult(maybeResult($\cdot$))! is
represented as a two-element stack. Thus, an invocation of an abstract
operation amounts to performing a dynamic lookup for a suitable
handler in a stack.

Since the primary use of handlers in OCaml is to express concurrency,
OCaml handlers are affine; continuations can only be resumed at most
once, and multiple invocations of a continuation causes a run-time
error. Multi-shot handlers can be simulated by manually cloning
continuations using \lstinline$Obj.clone_continuation$. The cost of
cloning is linear in the size of the handler stack. However, cloning
is a fragile abstraction; if the handler stack contains at least one
multi-shot handler, then every affine handler in the stack must be
demoted to a multi-shot handler to be safe, because a multi-shot
handler may consume a linear continuation more than
once. Consequently, multi-shot handlers in OCaml break modularity.

In the Links compiler we use the cloning capability under the hood to implement
multi-shot handlers. For example, our encoding of \lstinline$allResults$
amounts to the following in plain OCaml:
% \kc{$Obj.clone$ was too generic and I plan to use $Obj.clone\_continuation$ to
% be less ambiguous.}
\begin{lstlisting}[style=ocaml]
let all_results m = match m () with
 | x -> [x]
 | effect Choose k -> 
   let k' arg = 
     continue (Obj.clone_continuation k) arg 
   in k' true @ k' false
\end{lstlisting}
OCaml provides a unified syntax for pattern-matching on regular, effect, and
exception patterns. The keyword \lstinline[style=ocaml]$effect$ begins an
operation-clause. Essentially, we create a local function \lstinline$k'$, which
wraps the actual continuation \lstinline$k$. An invocation of \lstinline$k'$
passes its argument to a fresh copy of the actual continuation. The
\lstinline$continue$ function is provided by the standard library; given a
continuation and a value, it invokes the continuation with that particular
value. By default we implement every handler as a multi-shot handler.

%%
%% Evaluation
%%
\chapter{Experiments}
\label{ch:experiments}

\section{Experimental setup}
\label{sec:exp-setup}

%%
%% Formalisation
%%
\chapter{A calculus of handlers and rows}
\label{sec:lambe-eff-row}

In this section, we present a type and effect system and a small-step
operational semantics for \Calc (pronounced ``lambda-eff-row''), a
Church-style row-polymorphic call-by-value calculus for effect
handlers.
%
This core calculus captures the essence of the Links IR.
%
We prove that the operational semantics is sound with respect to the
type and effect system.

A key advantage of row polymorphism is that it integrates rather
smoothly with Hindley-Milner type inference. We concern ourselves only
with the explicitly-typed core language, as the treatment of type
inference is quite standard.

The design of \Calc is inspired by the $\lambda$-calculi of
\citet{Kammar2013}, \citet{Pretnar2015}, and \citet{Lindley2012}.
%
As in the work of \citet{Kammar2013}, each handler can have its own
effect signature. As in the work of \citet{Pretnar2015}, the
underlying formalism is fine-grain call-by-value~\cite{LevyPT03},
which names each intermediate computation like in A-normal
form~\cite{Flanagan1993}, but unlike A-normal form is closed under
$\beta$-reduction. As in the work of \citet{Lindley2012}, the effect
system is based on row polymorphism.

\section{Types}
The grammars of types, effects, kinds, and type and kind environments
are given in Figure~\ref{fig:types-syntax}.

\begin{figure}
Types
\begin{syntax}
\slab{Value types}    &A,B  &::= & %\Bool \mid \Int
                                      A \to C
                               \mid  \forall \alpha^K.C \\
                             &&\mid& \Record{R} \mid [R]
                               \mid  C \Rightarrow D \mid \alpha \\
                               %% \mid  \Harrow{A}{E}{B}{E'} \mid \alpha \\
\slab{Computation types} 
                      &C,D  &::= & A \eff E \\
\slab{Effect types}   &E    &::= & \{R\}\\
\slab{Row types}      &R    &::= & \ell : P;R \mid \rho \mid \cdot \\
\slab{Presence types} &P    &::= & \Pre{A} \mid \Abs \mid \theta\\
%\slab{Labels}         &\ell &    &                \\
\slab{Kinds}          &K    &::= & \Type \mid \Row_\mathcal{L} \mid \Presence\\
\slab{Label sets}     &\mathcal{L} &::=& \emptyset \mid \{\ell\} \uplus \mathcal{L}\\
%\slab{Type variables} &\alpha, \rho, \theta& \\
\slab{Type environments} &\Gamma &::=& \cdot \mid \Gamma, x:A \\
\slab{Kind environments} &\Delta &::=& \cdot \mid \Delta, \alpha:K \\
\end{syntax}
\caption{Types, effects, kinds, and environments}
\label{fig:types-syntax}
\end{figure}

\paragraph{Value Types}
%The base types are integers and booleans.
The function type $A \to C$ takes an argument of type $A$ and returns
a computation of type $C$.
%% The effect signature enumerates the
%% operations that the function may perform during evaluation.
The polymorphic type $\forall \alpha^K .\, C$ is parameterised by a
type variable $\alpha$ of kind $K$. The record type $\Record{R}$
represents records with fields given by labels of row $R$. Dually, the
variant type $[R]$ represents a sum of fields tagged by the labels of
row $R$. The handler type $C \Rightarrow D$ transforms a computation
of type $C$ into a computation of type $D$.

\paragraph{Computation Types}
A computation type $A \eff E$ is given by a value type $A$ and an
effect $E$, which specifies the operations that the computation may
perform.

\paragraph{Row Types}
Effect types, records and variants are defined in terms of rows.
A row type embodies a collection of distinct labels, each of which is
annotated with a presence type. A presence type indicates whether a
label is \emph{present} with some type $A$ ($\Pre{A}$), \emph{absent}
($\Abs$) or \emph{polymorphic} in its presence ($\theta$).

Row types are either \emph{closed} or \emph{open}. A closed row type
ends in~$\cdot$, whilst an open row type ends with a \emph{row
  variable} $\rho$. Furthermore, a closed row term can have only the
labels explicitly mentioned in its type. Conversely, the row variable
in an open row can be instantiated with additional labels. We identify
rows up to reordering of labels, for instance, we consider the
following two rows equivalent:
\[ \ell_1 : P_1; \cdots; \ell_n : P_n \equiv \ell_n : P_n; \cdots ; \ell_1 : P_1. \]
The unit and empty type are definable in terms of row types. We define
the unit type as the empty, closed record, that is,
$\Record{\cdot}$. Similarly, we define the empty type as the empty,
closed variant $[\cdot]$. Usually, we usually omit the $\cdot$ for
closed rows.

\paragraph{Kinds}
We have three kinds: $Type$, $\emph{Row}_\mathcal{L}$ and $Presence$
which classify value types, row types and presence types,
respectively. Row kinds are annotated with a set of labels
$\mathcal{L}$. The kind of a complete row is
$Row_{\mathcal{\emptyset}}$. More generally, the kind
$Row_{\mathcal{L}}$ denotes a partial row which cannot mention the
labels in $\mathcal{L}$.
%

\paragraph{Type Variables}
We let $\alpha$, $\rho$ and $\theta$ range over type variables. By
convention we use $\alpha$ for value type variables or for type
variables of unspecified kind, $\rho$ for type variables of row kind,
and $\theta$ for type variables of presence kind.

\paragraph{Type and Kind Environments}
Type environments map term variables to their types and kind
environments map type variables to their kinds.

\section{Terms}
\begin{figure}
\begin{syntax}
                             % SL: no need for constants in the core calculus
%\slab{Constants}     &c    &::= & n \mid \True \mid \False \\
\slab{Values}        &V,W  &::= & x
                             %\mid c
                             \mid \lambda x^A .\, M \mid \Lambda \alpha^K .\, M  \\
                     &     &\mid& \Record{} \mid \Record{\ell = V;W} \mid (\ell\, V)^R \\
                     &     &    &\\
\slab{Computations}  &M,N  &::= & V\,W \mid V\,A\\
                     &     &\mid& \Let\; \Record{\ell=x;y} \revto V \; \In \; N\\
                     &     &\mid& \Case\; V \{\ell\; x \mapsto M; y \mapsto N\} \mid \Absurd^C V\\
                     &     &\mid& \Return\; V \\
                     &     &\mid& \Let \; x \revto M \; \In \; N\\
                     &     &\mid& (\Do \; \ell \; V)^E \\
                     &     &\mid& \Handle \; M \; \With \; H\\
                     &     &    &\\
\slab{Handlers}      &H    &::= & \{ \Return \; x \mapsto M \} \\
                     &     &\mid& \{ \ell \; x \; k \mapsto M \} \uplus H \\
%% \slab{Integers}      &n    &      \\
%% \slab{Variables}     &x,y,z,k &    & \\
\end{syntax}

\caption{Term Syntax}
\label{fig:term-syntax}
\end{figure}
The terms are given in Figure~\ref{fig:term-syntax}. We let $x,y,z,k$
range over term variables. By convention, we use $k$ to denote
continuation names. %We let $n$ range over integer constants.

The syntax partitions terms into values, computations and
handlers. 
%
Value terms comprise variables ($x$), %constants ($c$),
lambda abstraction ($\lambda x^A . \, M$), type abstraction ($\Lambda
\alpha^K . \, M$), and the introduction forms for records and
variants. Records are introduced using the empty record $\Record{}$
and record extension $\Record{\ell = V; W}$, whilst variants are
introduced using injection $(\ell\, V)^R$ which injects a field with
label $\ell$ and value $V$ into a row whose type is $R$. We include
the row type annotation in order to support bottom-up type
reconstruction.

All elimination forms are computation terms. Abstraction and type
abstraction are eliminated using application ($V\,W$) and type
application ($V\,A$) respectively.
%
The record eliminator $(\Let \; \Record{\ell=x;y} \revto V \; \In \;
N)$ splits a record $V$ into $x$, the value associated with $\ell$,
and $y$, the rest of the record. Non-empty variants are eliminated
using the case construct ($\Case\; V\; \{\ell\; x \mapsto M; y \mapsto
N\}$), which evaluates the computation $M$ if the tag of $V$ matches
$\ell$, otherwise it falls through to $y$ and evaluates $N$.  The
elimination form for empty variants is ($\Absurd^C V$). A trivial
computation $(\Return\;V)$ returns value $V$. The expression $(\Let \;
x \revto M \; \In \; N)$ evaluates $M$ and binds the result value to
$x$ in $N$.

The construct $(\Do \; \ell \; V)^E$ invokes an operation $\ell$ with
value argument $V$. The handle construct $(\Handle \; M \; \With \;
H)$ runs a computation $M$ with handler definition $H$. A handler
definition $H$ consists of a return clause $\Return \; x \mapsto M$
and a possibly empty set of operation clauses $\{\ell_i \; x_i \; k_i
\mapsto M_i\}_i$. The return clause defines how to handle the final
return value of the handled computation, which is bound to $x$ in $M$.
%
The $i$-th operation clause binds the operation parameter to $x_i$ and
a the continuation $k_i$ in $M_i$.

We write $Id(M)$ for $\Handle \;M\; \With \; \{\Return\;x \mapsto
x\}$.
%
We write $H(\Return)$ for the return clause of $H$ and $H(\ell)$ for
the set of either zero or one operation clauses in $H$ that handle the
operation $\ell$. We write $dom(H)$ for the set of operations handled
by $H$.
%
As our calculus is Church-style, we annotate various term forms with
type or kind information (term abstraction, type abstraction,
injection, operations, and empty cases); we sometimes omit these
annotations.

%% SL: possibly a bit draconian, but I think we can do without the
%% detail here.

%% The terms of \Calc are written in a style reminiscent of
%% \emph{A-normal form} (ANF). ANF is a direct style intermediate
%% language in which every intermediate computation is let-bound
%% \cite{Flanagan1993}. As a consequence application consist of a value
%% applied to another value. For example, consider the Links expression
%% \lstinline$f(g(42))$, we must let bind the argument of \lstinline$f$
%% in order to bring the expression into ANF; we do not need to let bind
%% the argument of \lstinline$g$, since it is already a value, thus we
%% obtain the following ANF expression:
%% \[
%% \Let\; x \revto g\,42\; \In \; f\, x.
%% \]
%% However, ANF is not closed under $\beta$-reduction
%% \cite{Sabry1996,Kennedy2007}, since function application can lead to
%% nested \Let{}s. Consider the following example, which is adapted from
%% \citet{Sabry1996}:
%% \[ 
%%   \Let\; x \revto (\lambda y . \, \Let\; z \revto f \, a \;\In \; M) \, b \; \In\; N
%% \]
%% which $\beta$-reduces to 
%% \[
%%   \Let\; x \revto (\Let\; z \revto f \, a \;\In \; M) \; \In\; N
%% \]
%% which is not in ANF, because $x$ is bound to a computation rather than
%% a value. ANF can be recovered by adding a normalisation step
%% \cite{Sabry1996}.  We simplify our presentation by permitting nested
%% let-bindings and handlers to be applied directly to computations. The
%% resulting calculus is closer to fine-grained
%% call-by-value~\cite{LevyPT03}.

%% ,
%% therefore we say that \Calc-terms are in \emph{relaxed A-normal
%%   form} (RANF).

% As an example consider the translation of the Links expression \linksify{f(g(42),\{ var y = 1; h(y) \})} into its ANF. For clarity, we highlight the reducible term with a box:
% \begin{align*}
%             &  \fbox{\linksify{f(g(42),\{ var y = true; h(y) \})}}\\
% \Rightarrow &\quad\Let \; x_1 \revto g \; 42 \; \In\\
%             &\quad\quad\fbox{\linksify{f($x_1$,\{ var y = true; h(y) \})}}\\
% \Rightarrow &\quad\Let \; x_1 \revto g \; 42 \; \In\\
%             &\quad\quad\Let \; y \revto \Return \; \True \; \In\\
%             &\quad\quad\quad\fbox{\linksify{f($x_1$,h($y$))}}\\
% \Rightarrow &\quad\Let \; x_1 \revto g \; 42 \; \In\\
%             &\quad\quad\Let \; y \revto \Return \; \True \; \In\\
%             &\quad\quad\quad\Let \; x_2 \revto h \; y \; \In\\
%             &\quad\quad\quad\quad(f \; x_1)\; x_2
% \end{align*}
% Accordingly, the function \linksify{f} is applied only to value terms. Every subexpression gets decomposed into a single value gradually. As a consequence every subexpression has been explicitly named, thus in this respect, ANF is similar to the predominant imperative Static Single Assignment form.

\section{Static Semantics}
\label{sec:typing}
The kinding rules are given in Figure~\ref{fig:kinding} and the typing
rules are given in Figure~\ref{fig:typing}.

The kinding judgement $\Delta \vdash \alpha : K$ asserts that the type
variable $\alpha$ has kind $K$ in kind environment $\Delta$. The value
typing judgement $\typv{\Delta;\Gamma}{V : A}$ states that value term
$V$ has type $A$ under kind environment $\Delta$ and type environment
$\Gamma$. The computation typing judgement $\typc{\Delta;\Gamma}{M :
  A}{E}$ states that the term $M$ has type $A$ and effects $E$ under
kind environment $\Delta$ and type environment $\Gamma$. In typing
judgements, we implicitly assume that $\Gamma$, $E$ and $A$ are
well-kinded with respect to $\Delta$. We define the functions
$FTV(\Gamma)$ and $FTV(E)$ to be the set of free type variables in
$\Gamma$ and $E$, respectively.
%
%% We write $FTV(\Gamma,E)$ as shorthand for $FTV(\Gamma) \cup FTV(E)$.

The kind and typing rules are mostly straightforward. The interesting
typing rules are \tylab{Handle} and the two handler rules. The
\tylab{Handle} rule states that $\Handle\; M\; \With\; H$ produces a
computation of type $B$ given that the computation $M$ is typeable
under effect context $E$, and that $H$ is a handler which transforms a
computation of type $A$ with effect signature $E$ into another
computation of type $B$ with effect signature $E'$.

The \tylab{Handler} rule is crucial. The input effect $E$ and the
output effect $E'$ must share the same suffix $R$. This means that
$E'$ must explicitly mention each of the operations $\ell_i$, whether
that be to say that an $\ell_i$ is present with a given type
signature, absent, or polymorphic in its presence. The row $R$
describes the operations that are forwarded. It may include a
row-variable, in which case an arbitrary number of effects may be
forwarded by the handler.
%
The typing of the return clause is straightforward. In the typing of
each operation clause, the continuation returns the output computation
type $D$. Thus, we are here defining \emph{deep}
handlers~\cite{Kammar2013} in which the handler is implicitly wrapped
around the continuation, such that any subsequent operations are
handled uniformly by the same handler.
%
The Links implementation also supports \emph{shallow}
handlers~\cite{Kammar2013}, in which the continuation is instead
annotated with the input effect and one has to explicitly reinvoke the
handler after applying the continuation inside an operation clause.

%% \todo{Insert a forward reference to discussion of shallow handlers
%%   elsewhere.}

%% The \tylab{Deep} and \tylab{Shallow} rules for handlers describe how
%% to type deep and shallow handlers, respectively. The two rules are
%% similar, but differ crucially in their typing of the continuation
%% parameter $k$. The different typing is due to their different
%% behaviour. A deep handler wraps itself around continuations such that
%% any subsequent operations are handled uniformly. Therefore the return
%% type of a continuation type must match the input type of the
%% \Return{} case, and in particular, its effect signature must be the
%% same as the handler's output effect signature $E'$. Conversely, in a
%% shallow handler the continuation is annotated with the input effect
%% signature $E$ rather than the output effect signature. Moreover, the
%% return type $A$ is the same as return type of the handled
%% computation. Shallow handlers do not wrap themselves around the
%% continuation, therefore the continuation must be applied explicitly to
%% handler which has to handle the next operation
%% invocation. Consequently, operations may be handled non-uniformly.

%% For both handler types the input effect signature is a disjoint union
%% of operation signatures, that the handler directly interprets, and
%% some set $E_f$. The metavariable $E_f$ can be instantiated with a row
%% variable to include operations that are not explicitly mentioned by
%% the handler.

\begin{figure}
\begin{mathpar}
% alpha : K
  \inferrule*[Lab=\klab{TyVar}]
    { }
    {\Delta, \alpha : K \vdash \alpha : K}

% forall alpha : K . A : Type
  \inferrule*[Lab=\klab{Forall}]
    { \Delta, \alpha : K \vdash A : \Type \\
      \Delta, \alpha : K \vdash R : \Row_\emptyset}
    {\Delta \vdash (\forall \alpha^K . \, A \eff \{R\}) : \Type}
%%
%% % Int : Type
%%   \inferrule*[Lab=\klab{Int}]
%%     { }
%%     {\Delta \vdash \Int : \Type}
%%
%% % Bool : Type
%%   \inferrule*[Lab=\klab{Bool}]
%%     { }
%%     {\Delta \vdash \Bool : \Type}

% A -E-> B, A : Type, E : Row, B : Type
  \inferrule*[Lab=\klab{Fun}]
    { \Delta \vdash A : \Type \\
      \Delta \vdash R : \Row_\emptyset  \\
      \Delta \vdash B : \Type
    }
    {\Delta \vdash (A \to B \eff \{R\}) : \Type}

% Record
  \inferrule*[Lab=\klab{Record}]
    { \Delta \vdash R : \Row_\emptyset}
    {\Delta \vdash \Record{R} : \Type}

% Variant
  \inferrule*[Lab=\klab{Variant}]
    { \Delta \vdash R : \Row_\emptyset}
    {\Delta \vdash [R] : \Type}

% Present
  \inferrule*[Lab=\klab{Present}]
    {\Delta \vdash A : \Type}
    {\Delta \vdash \Pre{A} : \Presence}

% Absent
  \inferrule*[Lab=\klab{Absent}]
    { }
    {\Delta \vdash \Abs : \Presence}

% Empty row
  \inferrule*[Lab=\klab{EmptyRow}]
    { }
    {\Delta \vdash \cdot : \Row_\mathcal{L}}

% Extend row
  \inferrule*[Lab=\klab{ExtendRow}]
    { \Delta \vdash P : \Presence \\
      \Delta \vdash R : \Row_{\mathcal{L} \uplus \{\ell\}}
    }
    {\Delta \vdash \ell : P;R : \Row_\mathcal{L}}
\end{mathpar}

\caption{Kinding Rules}
\label{fig:kinding}
\end{figure}

\begin{figure*}
Values
\begin{mathpar}
% Variable
  \inferrule*[Lab=\tylab{Var}]
    {x : A \in \Gamma}
    {\typv{\Delta;\Gamma}{x : A}}
%%
%% % true : Bool
%%   \inferrule*[Lab=\tylab{True}]
%%     { }
%%     {\typv{\Delta;\Gamma}{\True : \Bool}}
%%
%% % false : Bool
%%   \inferrule*[Lab=\tylab{False}]
%%     { }
%%     {\typv{\Delta;\Gamma}{\False : \Bool}}
%%
%% % n : Int
%%   \inferrule*[Lab=\tylab{Int}]
%%     { n \in \mathbb{N} }
%%     {\typv{\Delta;\Gamma}{n : \Int}}

% Abstraction
  \inferrule*[Lab=\tylab{Lam}]
    {\typ{\Delta;\Gamma, x : A}{M : C}}
    {\typv{\Delta;\Gamma}{\lambda x^A .\, M : A \to C}}

% Polymorphic abstraction
  \inferrule*[Lab=\tylab{PolyLam}]
    {\typc{\Delta,\alpha : K;\Gamma}{M : A}{E} \\
     \alpha \notin FTV(\Gamma)
    }
    {\typv{\Delta;\Gamma}{\Lambda \alpha^K .\, M : \forall \alpha^K . \,A \eff E}}
\\
% unit : ()
  \inferrule*[Lab=\tylab{Unit}]
    { }
    {\typv{\Delta;\Gamma}{\Record{} : \Record{}}}

% Extension
  \inferrule*[Lab=\tylab{Extend}]
    { \typv{\Delta;\Gamma}{V : A} \\
      \typv{\Delta;\Gamma}{W : \Record{\ell:\Abs;R}}
    }
    {\typv{\Delta;\Gamma}{\Record{\ell=V;W} : \Record{\ell:\Pre{A};R}}}

% Inject
  \inferrule*[Lab=\tylab{Inject}]
    {\typv{\Delta;\Gamma}{V : A}}
    {\typv{\Delta;\Gamma}{(\ell\,V)^R : [\ell : \Pre{A}; R]}}
\end{mathpar}
Computations
\begin{mathpar}
% Application
  \inferrule*[Lab=\tylab{App}]
    {\typv{\Delta;\Gamma}{V : A \to C} \\
     \typv{\Delta;\Gamma}{W : B}
    }
    {\typ{\Delta;\Gamma}{V\,W : C}}

% Polymorphic application
  \inferrule*[Lab=\tylab{PolyApp}]
    {\typv{\Delta;\Gamma}{V : \forall \alpha^K . \, C} \\
     \Delta \vdash A : K
    }
    {\typ{\Delta;\Gamma}{V\,A : C[A/\alpha]}}

% Split
  \inferrule*[Lab=\tylab{Split}]
    {\typv{\Delta;\Gamma}{V : \Record{\ell : \Pre{A};R}} \\\\
     \typ{\Delta;\Gamma, x : A, y : \Record{\ell : \Abs; R}}{N : C}
    }
    {\typ{\Delta;\Gamma}{\Let \; \Record{\ell =x;y} \revto V\; \In \; N : C}}

% Case
  \inferrule*[Lab=\tylab{Case}]
    { \typv{\Delta;\Gamma}{V : [\ell : \Pre{A};R]}  \\\\
      \typ{\Delta;\Gamma,x:A}{M : C} \\\\
      \typ{\Delta;\Gamma,y:[\ell : \Abs;R]}{N : C}
    }
    {\typ{\Delta;\Gamma}{\Case \; V \{\ell\; x \mapsto M;y \mapsto N \} : C}}

% Absurd
  \inferrule*[Lab=\tylab{Absurd}]
    {\typv{\Delta;\Gamma}{V : []}}
    {\typ{\Delta;\Gamma}{\Absurd^C \; V : C}}

% Return
  \inferrule*[Lab=\tylab{Return}]
    {\typv{\Delta;\Gamma}{V : A}}
    {\typc{\Delta;\Gamma}{\Return \; V : A}{E}}

% Let 
  \inferrule*[Lab=\tylab{Let}]
    {\typc{\Delta;\Gamma}{M : A}{E} \\
     \typc{\Delta;\Gamma, x : A}{N : B}{E}
    }
    {\typc{\Delta;\Gamma}{\Let \; x \revto M\; \In \; N : B}{E}}
\\
% Do 
  \inferrule*[Lab=\tylab{Do}]
    {\typv{\Delta;\Gamma}{V : A} \\
     E = \{\ell : A \to B; R\}
    }
    {\typc{\Delta;\Gamma}{(\Do \; \ell \; V)^E : B}{E}}

% Open Handle
  \inferrule*[Lab=\tylab{Handle}]
    {\typv{\Delta;\Gamma}{M : C} \\
     \Delta;\Gamma \vdash H : C \Rightarrow D}
    {\typv{\Delta;\Gamma}{\Handle \; M \; \With \; H : D}}
\end{mathpar}

Handlers
\begin{mathpar}
% Closed handler
% \mprset{flushleft}
% \inferrule*[Lab=\tylab{Deep-Closed}]
%     { E = \{\ell_i : A_i \to B_i\}_i \\\\
%       H = \{\Return \; x \mapsto M\} \uplus \{\ell_i \; y_i \; k_i \mapsto N_i\}_i \\\\
%       \left[\Delta;\Gamma,y_i : A_i, k_i : B_i \xrightarrow{E'} C \vdash_{E'} N_i : C\right]_i \\\\
%       \Delta;\Gamma, x : A \vdash_{E'} M : C
%     }
%     {\Delta;\Gamma \vdash_{E'} H : (\Record{} \xrightarrow{E} A) \xrightarrow{E'} C}   

% Open handler
%\mprset{flushleft}
  \inferrule*[Lab=\tylab{Handler}]
    {
      C = A \eff \{(\ell_i : A_i \to B_i)_i; R\} \\
      D = B \eff \{(\ell_i : P_i)_i;         R\} \\
      H = \{\Return \; x \mapsto M\} \uplus \{\ell_i \; y \; k \mapsto N_i\}_i \\\\
      [\typv{\Delta;\Gamma,y : A_i, k : B_i \to D}{N_i : D}]_i \\
       \typv{\Delta;\Gamma, x : A}{M : D} \\
    }
    {{\Delta;\Gamma} \vdash {H : C \Rightarrow D}}

% Shallow closed handler
% \inferrule*[Lab=\tylab{Shallow-Closed}]
%     { E = \{\ell_i : A_i \to B_i\}_i \\\\
%       H = \{\Return \; x \mapsto M\} \uplus \{\ell_i \; y_i \; k_i \mapsto N_i\}_i \\\\
%       \left[\Delta;\Gamma,y_i : A_i, k_i : B_i \xrightarrow{E} A \vdash_{E'} N_i : C\right]_i \\\\
%       \Delta;\Gamma, x : A \vdash_{E'} M : C
%     }
%     {\Delta;\Gamma \vdash_{E'} H : (\Record{} \xrightarrow{E} A) \xrightarrow{E'} C}   

%% SL: we should mention this rule later

%% % Shallow open handler
%%   \inferrule*[Lab=\tylab{Shallow}]
%%     { E = \{\ell_i : A_i \to B_i\}_i \uplus E_f \\\\
%%       E' = E'' \uplus E_f \\\\
%%       H = \{\Return \; x \mapsto M\} \uplus \{\ell_i \; y \; k \mapsto N_i\}_i \\\\
%%       \left[\Delta;\Gamma,y : A_i, k : B_i \xrightarrow{E} A \vdash_{E'} N_i : C\right]_i \\\\
%%       \Delta;\Gamma, x : A \vdash_{E'} M : C
%%     }
%%     {\Delta;\Gamma \vdash_{E'} H : A \harrow{E}{E'} C}
\end{mathpar}

\caption{Typing Rules}
\label{fig:typing}
\end{figure*}

\section{Operational Semantics}
\label{sec:small-step}

\begin{figure*}

\begin{reductions}
\semlab{App}   & (\lambda x^A . \, M) V &\reducesto& M[V/x] \\
\semlab{TyApp} & (\Lambda \alpha^K . \, M) A &\reducesto& M[A/\alpha] \\
\semlab{Split} & \Let \; \Record{\ell = x;y} \revto \Record{\ell = V;W} \; \In \; N &\reducesto& N[V/x,W/y] \\
\semlab{Case$_1$} &
  \Case \; (\ell\, V)^R \{ \ell \; x \mapsto M; y \mapsto N\} &\reducesto& M[V/x] \\
\semlab{Case$_2$} &
  \Case \; (\ell\, V)^R \{ \ell' \; x \mapsto M; y \mapsto N\} &\reducesto& N[(\ell\, V)^R/y], \hfill\quad \text{if } \ell \neq \ell' \\
\semlab{Let} &
  \Let \; x \revto \Return \; V \; \In \; N &\reducesto& N[V/x] \\
\semlab{Handle-Ret} &
  \Handle \; (\Return \; V) \; \With \; H &\reducesto& M[V/x], \hfill\quad \text{where } \{ \Return \; x \mapsto M \} \in H \\
\semlab{Handle-Op} &
  \Handle \; \mathcal{E}[\Do \; \ell \; V] \; \With \; H
    &\reducesto& M[V/x, \lambda y . \, \Handle \; \mathcal{E}[\Return \; y] \; \With \; H/k],\qquad \\
  \multicolumn{4}{@{}r@{}}
      {\text{where } \ell \notin BL(\mathcal{E}) \text{ and } \{ \ell \; x \; k \mapsto M \} \in H} \\
\end{reductions}
\begin{syntax}
\slab{Evaluation contexts} &  \mathcal{E} &::=& [\,] \mid \Let \; x \revto \mathcal{E} \; \In \; N \mid \Handle \; \mathcal{E} \; \With \; H
\end{syntax}
\[
% Evaluation context lift
\inferrule*[Lab=\semlab{Lift}]
  { M \reducesto N }
  { \mathcal{E}[M] \reducesto \mathcal{E}[N]}
\]

\caption{Small-step Operational Semantics}
\label{fig:small-step}
\end{figure*}
We give a small-step operational semantics for \Calc. Figure
\ref{fig:small-step} displays the operational rules. The reduction
relation $\reducesto$ is defined on computation terms. The statement $M
\reducesto M'$ reads: term $M$ reduces to term $M'$ in a single
step. Most of the rules are standard. We use
%% \emph{delimited
%%   computation contexts} and
\emph{evaluation contexts} to simplify the evaluation rules, by
allowing us to focus on an active expression. The interesting rules
are the handler rules.

We write $BL(\mathcal{E})$ for the set of operation labels bound by
$\mathcal{E}$.
\begin{equations}
BL([~])                            &=& \emptyset \\
BL(\Let\;x \revto \mathcal{E}\;\In\;N)    &=& BL(\mathcal{E}) \\
BL(\Handle\;\mathcal{E}\;\With\;H) &=& BL(\mathcal{E}) \cup dom(H) \\
\end{equations}

The rule \semlab{Handle-Ret} invokes the return clause of a
handler. The rule \semlab{Handle-op} handles an operation by invoking
the appropriate operation clause. The constraint $\ell \notin
BL(\mathcal{E})$ ensures that no inner handler inside the evaluation
context is able to handle the operation: thus a handler is able to
reach past any other inner handlers that do not handle $\ell$. In our
abstract machine semantics we realise this behaviour using explicit
forwarding operations, but more efficient implementations are
perfectly feasible.


We write $R^+$ for the transitive closure of relation $R$.
%
Subject reduction and type soundness for $\Calc$ are standard.

\begin{theorem}[Subject Reduction]
If $\typc{\Delta;\Gamma}{M : A}{E}$ and $M \reducesto M'$, then
$\typc{\Delta;\Gamma}{M' : A}{E}$.
\end{theorem}

There are two ways in which a computation can terminate. It can either
successfully return a value, or it can get stuck on an unhandled
operation.
\begin{definition}
We say that computation term $N$ is normal with respect to effect $E$,
if $N$ is either of the form $\Return\;V$, or
$\mathcal{E}[\Do\;\ell\;W]$, where $\ell \in E$ and $\ell \notin
BL(\mathcal{E})$.
\end{definition}
If $N$ is normal with respect to the empty effect $\{\cdot\}$, then
$N$ has the form $\Return\;V$.

\begin{theorem}[Type Soundness]
If $\typc{}{M : A}{E}$, then there exists $\typc{}{N : A}{E}$, such that
$M \reducesto^+ N \not\reducesto$, and $N$ is normal with respect to
effect $E$.
\end{theorem}

%%
%% Conclusions and future work
%%
\chapter{Conclusions and future work}
\label{ch:conclusions}
\section{Future work}
\label{sec:futurework}

%%
%% Appendices
%%
\appendix
\chapter{Installing the Links compiler}
\label{ch:install}

%%%%%%%%
%% Include your chapter files here. See the sample chapter file for the basic
%% format.

%\input{content/index}

%% If you want the bibliography single-spaced (which is allowed), uncomment
%% the next line.
\nocite{*}
\singlespace
%\printbibliography[heading=bibintoc]
\bibliographystyle{abbrvnat}
\bibliography{references}

%% ... that's all, folks!
\end{document}
